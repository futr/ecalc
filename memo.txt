
メモリ
WindowsならVirtualAllocで確保
Linux
http://d.hatena.ne.jp/syuu1228/20100118/1263838577

呼び出し規約(x86)
cdecl
右からプッシュ
プロトタイプがない場合の拡張はおそらくC
呼び出し側がスタックの責任を持つ
eax-edxは割と自由に使える(壊してもいい)
ebxは保存すべき（壊しちゃダメ）
普通の戻り値はeax
戻り値が構造体とかの場合eaxにアドレスが入る
その領域はどこにあるかは謎（コール前に確保しておく？）
EBP+8が最初の引数(32bit)
引数が1バイトの場合は?


eaxはポインタ用
ecxはなんか色々用(主にEAXのバッファ)
ebxは定数用
のような感じで使ってみる


浮動少数の３は
アドレスが低い方から
低い　　　　　高い
00 00 00 00 00 00 08 40
として入っている
リトルエンディアンなのだろうから値としては
0x40 08 00 00 00 00 00 00
スタック上につまれた値を見ると
0x40 08 00 00
0x00 00 00 00
の順でLEで積まれている
つまり、その引数を指す場所にebp+posで行って、8バイト取得すれば
実数値が得られるのではないかな？
doubleの転送には、FPUのスタックを使うと１命令で実行できて楽だし速いかもしれない(bccがやってた)

double *vars, double ans
のansにアクセスするには
[ebp+12]から8バイト

関数ポインタはリンク時に初期化出来るのか？
できた

考えるのがめんどくさいので、デバッガでバイナリを引っ張ってくることにする

その演算子の結果は浮動小数点スタックのトップに常にある
みたいにする？
左辺値、右辺値バッファをとする？
st(0),st(1)
結果はst(0)

EAXをメモリアクセス用ポインタにする
全部EAX経由でアクセスする

めんどくさいからそれぞれ細かい動作を印刷関数に分ける
即値保存(スタック位置指定)
PUSH（即値）
PUSH（スタック位置指定）
POP(スタック位置指定)
関数コール（関数ポインタ配列スタック位置、関数番号）
FPUPOP(スタック位置)
FPUPUSH(スタック位置)
EAXに引数アドレス読み込み

32bit転送命令しか使わない場合、doubleの即値転送もmov二かい
[eax+]


ebpに配列の先頭アドレスをセット
Opening

push ebp			55
mov ebp, esp		8BEC
mov eax, [ebp+0x08]	8B4508

Closing

pop ebp				5D
ret					C3



fld qword ptr []




http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/lecture/os/lang106.html
http://inaz2.hatenablog.com/entry/2014/05/30/004109
http://milkpot.sakura.ne.jp/note/x86.html
http://7ujm.net/linux/asm.html
http://sandpile.org/x86/opc_enc.htm
http://www.intel-assembler.it/portale/5/The-8087-Instruction-Set/A-one-line-description-of-x87-instructions.asp
http://unixwiz.net/techtips/win32-callconv-asm.html
http://unixwiz.net/techtips/x86-jumps.html

http://7shi.hateblo.jp/entries/2012/06/10
http://7shi.hateblo.jp/entry/2012/04/21/154847
linuxではmmap？

BFの実装　おもしろそう
8664のコーリングコンバージョンもある
http://kylem.net/programming/bf_interp.html

オンラインディスアセンブラ
すごい
http://www2.onlinedisassembler.com/odaweb/

### GASで命令をバイナリに変換する
Ctrl+D(EOF)で終わる
as -march=i686 --32 -msyntax=intel -mnaked-reg -aln -o /dev/null

同じ効果を持つ別の命令がある
http://stackoverflow.com/questions/19467610/why-does-nasm-use-0x89-when-it-assembles-a-mov-instruction-between-registers
例えばBCCは
mov ebp, esp : 8BEC
だが、gasは
mov ebp, esp : 89E5

jzはなぜか
0F 84 飛ぶ量-4のLE
という機械語になる。
デフォルトで4飛ぶのだろうか
相対アドレスの起点は次の命令の始点らしい
jzの命令長は6
多分、アセンブラの引数はラベル値（つまりある意味絶対アドレス）を
もらうことを仮定しているけど、命令の引数自体は相対なんじゃないのだろうか
   1 0000 7404          je l1
   2 0002 01C8          add eax,ecx
   3 0004 89C1          mov ecx,eax
   4                    l1:
   5 0006 89E5          mov ebp,esp

   1                    l1:
   2 0000 0F843A30      jz l1+0x10203040
   2      2010
ということは普通に相対アドレスを渡せばいいのでは


fstp st(0) で無意味POPができるみたい


calling conversions